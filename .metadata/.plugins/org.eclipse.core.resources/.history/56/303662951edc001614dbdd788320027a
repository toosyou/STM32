#include "stm32l476xx.h"
#include "core_cm4.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "usart.h"
#include "adc.h"
#include "util.h"
#include "74HC595.h"
#include "util.h"
#define MAX_SEND_COUNT 1000
#define MAX_MOVING_AVERAGE 5

typedef unsigned int bool;
#define false 0
#define true 1

extern void delay(int ms);

float moving_average[MAX_MOVING_AVERAGE];

float voltage = 0.0f;
int send_count = 0;
int led_mode = 1;

const int led_sequence[16] = {0, 1, 2, 3, 4, 5, 6, 7, 15, 9, 14, 13, 12, 11, 10, 8};

void send_to_shoes(HC595 ic, unsigned int data);

float get_moving_average(int new_voltage){
	float average = 0.0f;
	for(int i=MAX_MOVING_AVERAGE-1;i>0;--i){
		moving_average[i] = moving_average[i-1];
		average += moving_average[i];
	}
	moving_average[0] = new_voltage;
	average += new_voltage;
	return average / MAX_MOVING_AVERAGE;
}

void SysTickConfig(int tick){
	SysTick->CTRL &= ~(SysTick_CTRL_ENABLE_Msk);
	SysTick->LOAD = tick & SysTick_LOAD_RELOAD_Msk;
	SysTick->VAL = 0;
	SysTick->CTRL |= (SysTick_CTRL_CLKSOURCE_Msk);
	SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk;
	SysTick->CTRL |= SysTick_CTRL_ENABLE_Msk;
}

void SysTick_Handler(){
	convert_adc(ADC1);
	return;
}

void ADC1_2_IRQHandler(void){
	while(!(ADC1->ISR&ADC_ISR_EOC)); // wait for complete
	float voltage_max = 0.6f;
	float voltage_min = 0.5999995f;
	if(led_mode == -1){
		voltage_max = 0.6f;
		voltage_min = 0.5f;
	}

	float new_voltage = (float)read_adc(ADC1) / 4096.9f * 5.0f - voltage_min;
	new_voltage /= voltage_max - voltage_min;
	new_voltage = new_voltage > 1.0f ? 1.0f : new_voltage;
	new_voltage = new_voltage < 0.0f ? 0.0 : new_voltage;
	voltage = get_moving_average(new_voltage) + new_voltage*0.05;
	return;
}

void GPIO_Init(void) {
	RCC->AHB2ENR |= RCC_AHB2ENR_GPIOAEN;
	RCC->AHB2ENR |= RCC_AHB2ENR_GPIOCEN;

	//pa0
	gpio_set_alternate(GPIOA, 0);
	gpio_set_high_speed(GPIOA, 0);
	GPIOA->AFR[0] |= 0x00000001;
	GPIOA->AFR[0] &= 0xFFFFFFF1;

	// BUTTON	//PC13
	GPIOC->MODER &= ~(0b11 << (13*2));
	GPIOC->MODER |= (0b00 <<(13*2));
	GPIOC->OSPEEDR &= ~(0b11 << (13*2));
	GPIOC->OSPEEDR |= ~(0b01 << (13*2));
	GPIOC->OTYPER &= ~(1 << 13);
	GPIOC->PUPDR &= ~(0b11 << (13 * 2));
}

bool bottom_clicked(void){
    static int debounce = 0;
    if( (GPIOC->IDR & 0b10000000000000) == 0 ){ // pressing
        debounce = debounce+1 > 500 ? 500 : debounce+1;
    }
    else{
        if(debounce >= 500){
            debounce = 0;
            return true;
        }
        else
            debounce = 0;
    }
    return false;
}

void InitializeTimer(uint32_t presc){

	RCC->APB1ENR1 |= RCC_APB1ENR1_TIM2EN;
	TIM2->CR1 &= 0xFFFFFF8F; // count up & Edge-aligned
    TIM2->CR1 |= 0x80;

	TIM2->ARR = (uint32_t)256;//Reload value
	TIM2->PSC = (uint32_t)presc;//Prescaler
	TIM2->EGR = TIM_EGR_UG;//Reinitialize the counter

    TIM2->CCMR1 |= 6 << 4;
    TIM2->CCMR1 |= 1 << 3;

    TIM2->CCR1 = 500;

    TIM2->CCER |= 1;
    TIM2->BDTR |= 1<<15;
    TIM2->CR1 |= TIM_CR1_CEN;
}

void send_to_shoes(HC595 ic, unsigned int data){
	if(send_count > MAX_SEND_COUNT){
		send_count = 0;
		HC595Reset(ic);
	}

	int most_significant_8bits = 0;
	int least_significant_8bits = 0;
	int output_sequence[16];
	for(int i=0;i<16;++i){
		int index = led_sequence[i];
		if(i < 10)
			output_sequence[index] = ((data >> i) & 1) == 1 ? 0 : 1 ;
		else
			output_sequence[index] = (data >> i) & 1;
	}
	for(int i=0;i<8;++i){
		most_significant_8bits = (most_significant_8bits << 1) + output_sequence[15-i];
		least_significant_8bits = (least_significant_8bits << 1) + output_sequence[7-i];
	}

	HC595Send(ic, most_significant_8bits, false);
	HC595Send(ic, least_significant_8bits, true);
	send_count++;
	return;
}

void init_moving_average(void){
	for(int i=0;i<MAX_MOVING_AVERAGE;++i){
		moving_average[i] = 0.0f;
	}
	return;
}

void EXTISetup(){
	RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
	SYSCFG->EXTICR[0] = SYSCFG_EXTICR1_EXTI3_PB;
	SYSCFG->EXTICR[1] = SYSCFG_EXTICR2_EXTI4_PB | SYSCFG_EXTICR2_EXTI5_PB | SYSCFG_EXTICR2_EXTI6_PB;
	SYSCFG->EXTICR[3] = SYSCFG_EXTICR4_EXTI13_PC;
	EXTI->IMR1 |= EXTI_IMR1_IM3;
	EXTI->IMR1 |= EXTI_IMR1_IM4;
	EXTI->IMR1 |= EXTI_IMR1_IM5;
	EXTI->IMR1 |= EXTI_IMR1_IM6;
	EXTI->IMR1 |= EXTI_IMR1_IM13;
	EXTI->FTSR1 |= EXTI_FTSR1_FT3;
	EXTI->FTSR1 |= EXTI_FTSR1_FT4;
	EXTI->FTSR1 |= EXTI_FTSR1_FT5;
	EXTI->FTSR1 |= EXTI_FTSR1_FT6;
	EXTI->RTSR1 |= EXTI_RTSR1_RT13;
	NVIC_EnableIRQ(EXTI3_IRQn);
	NVIC_EnableIRQ(EXTI4_IRQn);
	NVIC_EnableIRQ(EXTI9_5_IRQn);
	NVIC_EnableIRQ(EXTI15_10_IRQn);
	NVIC_SetPriority(EXTI15_10_IRQn, 0);
	NVIC_SetPriority(SysTick_IRQn, 5);
	//display(NVIC_GetPriority(EXTI15_10_IRQn)*100+NVIC_GetPriority(SysTick_IRQn), 4);
}

int main(){
	SCB->CPACR |= (0xF << 20);
	init_moving_average();
	InitializeTimer(20);
	GPIO_Init();
	SysTickConfig(40000);
	usart_init();
	ADC_init();
	HC595 ic;
	ic.GPIO = GPIOA;
	ic.clk_pin = 5;
	ic.cs_pin = 6;
	ic.data_pin = 7;
	ic.reset_pin = 8;
	HC595Init(ic);
	send_to_shoes(ic, 0xFFFF);
	int data = 0;
	while(1){
		if(led_mode == 0){
			//0.5 - 0.6
			TIM2->CCR1 = (int)(256.0f * (1 - voltage) );
		}
		else if(led_mode == 1){
			unsigned int level = (unsigned int)(15.0f * voltage);
			TIM2->CCR1 = 0;
			send_to_shoes(ic, (1<<level) -1);
			delay(50);
		}
		else if(led_mode == -1){
			TIM2->CCR1 = 0;
			if(bottom_clicked()){
				send_to_shoes(ic, data++);
			}
		}
		/*for(int i=0;i<15;++i){
			send_to_shoes(ic, 1 << (i+1));
			delay(100000);
		}*/

		//TIM2->CCR1 = 128;


		//TIM2->CCR1 = (int)(256.0f * (1 - voltage) );
		//delay(33);
	}
	return 0;
}
